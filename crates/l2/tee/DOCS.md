# TDX execution module

## Usage

On a machine with TDX support [with the required setup](https://github.com/canonical/tdx) run
```
mkosi build
mkosi vm
```

## What is TDX?

TDX is an Intel technology implementing a Trusted Execution Environment.
Such an environment allows verifying certain code was executed without being tampered with or observed.

These verifications (attestations) are known as "quotes" and contain signatures verifying the attestation was generated by a genuine processor, the measurements at the time, and a user-provided piece of data binding the proof.

The measurements happen into four Run Time Measurement Registers (RTMR), with each RTMR respresenting a boot stage.
This is analogous to [how PCRs work](https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/).

## Usage considerations

Do not hardcode quote verification parameters as [they might change](https://cc-enabling.trustedservices.intel.com/intel-tdx-enabling-guide/02/infrastructure_setup/#tcb-recovery-tcb-r).

It's easy to silently overlook non-verified areas such as accidentally leaving login enabled, not verifying the integrity of the state.

## Boot sequence

- Firmware (OVMF here) is loaded (and hashed into RTMR[0])
- [UKI](https://uapi-group.org/specifications/specs/unified_kernel_image/) is loaded (and hashed into a RTMR)
- kernel and initrd are extracted from the UKI and executed
- root partition is verified using the `roothash=` value provided on the kernel cmdline and the `hash` partition with the dm-verity merkle tree
- root partition is mounted read-only
- (WIP) systemd executes the payload

## Image build components

To build images we use [mkosi](https://github.com/systemd/mkosi)

### Tooling image

`mkosi.tools.conf` defines the tool configuration, and `mkosi.tools.skeleton` imports the kobuk-team PPA (used by [canonical/tdx](https://github.com/canonical/tdx)) with the modified qemu build

This allows the build process to not depend on the host's tooling

### Image preparation

Runs `mkosi.prepare.chroot`, which has network access, to download crate dependencies.

### Image building

Runs `mkosi.build.chroot` to produce the output

## Debug suggestions

- Adding `bash` to mkosi scripts to drop an interactive shell that lets you explore the build process
- Adding a root password in `mkosi.conf` to allow logging in to the container


## Chain verification


```
# NOTE: initialize&update submodules on all repos
(ethrex) make dev # start L1
(ethrex crates/l2) make deploy-l1 # deploy create2 deployer
(daimo-eth/p256-verifier) scripts/deploy.sh # deploy P256 verifier
(automata-network/automata-on-chain-pccs) edit script/utils/P256Configuration.sol with daimo addr and chainid
(automata-network/automata-on-chain-pccs) forge install && make deploy-all
(automata-network/automata-on-chain-pccs) # look at deployment/CHAIN_ID.json
(automata-network/automata-dcap-attestation evm/deployment/) add CHAINID/onchain_pccs.json
(automata-network/automata-dcap-attestation evm/) edit script/utils/P256Configuration.sol with daimo addr and chainid
(automata-network/automata-dcap-attestation evm/) forge install && make deploy-all
(automata-network/automata-dcap-qpl automata-dcap-qpl-tool/) # edit and source env/automata_testnet
Replay [1], [2] and [3] against AutomataPcsDao, with `rex send CONTRACT_AutomataPcsDao 0 PRIVATE_KEY --calldata CALLDATA`
Run AutomataDcapAttestationFee.setQuoteVerifier(CONTRACT_V4QuoteVerifier)

# To validate a quote
(automata-network/automata-dcap-qpl automata-dcap-qpl-tool/) cargo run -- -p PRIVATE_KEY --chain_id=$CHAIN_ID --rpc_url=$RPC_URL --quote_hex QUOTE # Inserts missing pieces
Now AutomataDcapAttestationFee.verifyAndAttestOnChain(QUOTE) can validate the quote.
```

[1] CA ROOT https://explorer.ata.network/tx/0x3c44e3eb9c866052ff84f1b11d91440b36cfc28ea5aeed78264d17411089de3d
[2] PLATFORM https://explorer.ata.network/tx/0x8b615efe4016176183145e34e1d659acb2788ff6763e6645c6ab1a77b1a3a828
[3] ROOT CRL https://explorer.ata.network/tx/0xf6e5cffa806261b7fdff6c0623ed1361d6e12073f4af026200735d1d87b1dafe
