use crate::{
    errors::{OpcodeResult, VMError},
    vm::VM,
};

fn from_u8<'a>(x: u8) -> fn(&mut VM<'a>, u8) -> Result<OpcodeResult, VMError> {
    match x {
        0 => |_, _| Ok(OpcodeResult::Halt),
        1 => |vm: &mut VM<'a>, _| vm.op_add(),
        2 => |vm: &mut VM<'a>, _| vm.op_mul(),
        3 => |vm: &mut VM<'a>, _| vm.op_sub(),
        4 => |vm: &mut VM<'a>, _| vm.op_div(),
        5 => |vm: &mut VM<'a>, _| vm.op_sdiv(),
        6 => |vm: &mut VM<'a>, _| vm.op_mod(),
        7 => |vm: &mut VM<'a>, _| vm.op_smod(),
        8 => |vm: &mut VM<'a>, _| vm.op_addmod(),
        9 => |vm: &mut VM<'a>, _| vm.op_mulmod(),
        10 => |vm: &mut VM<'a>, _| vm.op_exp(),
        11 => |vm: &mut VM<'a>, _| vm.op_signextend(),
        16 => |vm: &mut VM<'a>, _| vm.op_lt(),
        17 => |vm: &mut VM<'a>, _| vm.op_gt(),
        18 => |vm: &mut VM<'a>, _| vm.op_slt(),
        19 => |vm: &mut VM<'a>, _| vm.op_sgt(),
        20 => |vm: &mut VM<'a>, _| vm.op_eq(),
        21 => |vm: &mut VM<'a>, _| vm.op_iszero(),
        22 => |vm: &mut VM<'a>, _| vm.op_and(),
        23 => |vm: &mut VM<'a>, _| vm.op_or(),
        24 => |vm: &mut VM<'a>, _| vm.op_xor(),
        25 => |vm: &mut VM<'a>, _| vm.op_not(),
        26 => |vm: &mut VM<'a>, _| vm.op_byte(),
        27 => |vm: &mut VM<'a>, _| vm.op_shl(),
        28 => |vm: &mut VM<'a>, _| vm.op_shr(),
        29 => |vm: &mut VM<'a>, _| vm.op_sar(),
        32 => |vm: &mut VM<'a>, _| vm.op_keccak256(),
        48 => |vm: &mut VM<'a>, _| vm.op_address(),
        49 => |vm: &mut VM<'a>, _| vm.op_balance(),
        50 => |vm: &mut VM<'a>, _| vm.op_origin(),
        51 => |vm: &mut VM<'a>, _| vm.op_caller(),
        52 => |vm: &mut VM<'a>, _| vm.op_callvalue(),
        53 => |vm: &mut VM<'a>, _| vm.op_calldataload(),
        54 => |vm: &mut VM<'a>, _| vm.op_calldatasize(),
        55 => |vm: &mut VM<'a>, _| vm.op_calldatacopy(),
        56 => |vm: &mut VM<'a>, _| vm.op_codesize(),
        57 => |vm: &mut VM<'a>, _| vm.op_codecopy(),
        58 => |vm: &mut VM<'a>, _| vm.op_gasprice(),
        59 => |vm: &mut VM<'a>, _| vm.op_extcodesize(),
        60 => |vm: &mut VM<'a>, _| vm.op_extcodecopy(),
        61 => |vm: &mut VM<'a>, _| vm.op_returndatasize(),
        62 => |vm: &mut VM<'a>, _| vm.op_returndatacopy(),
        63 => |vm: &mut VM<'a>, _| vm.op_extcodehash(),
        64 => |vm: &mut VM<'a>, _| vm.op_blockhash(),
        65 => |vm: &mut VM<'a>, _| vm.op_coinbase(),
        66 => |vm: &mut VM<'a>, _| vm.op_timestamp(),
        67 => |vm: &mut VM<'a>, _| vm.op_number(),
        68 => |vm: &mut VM<'a>, _| vm.op_prevrandao(),
        69 => |vm: &mut VM<'a>, _| vm.op_gaslimit(),
        70 => |vm: &mut VM<'a>, _| vm.op_chainid(),
        71 => |vm: &mut VM<'a>, _| vm.op_selfbalance(),
        72 => |vm: &mut VM<'a>, _| vm.op_basefee(),
        73 => |vm: &mut VM<'a>, _| vm.op_blobhash(),
        74 => |vm: &mut VM<'a>, _| vm.op_blobbasefee(),
        80 => |vm: &mut VM<'a>, _| vm.op_pop(),
        81 => |vm: &mut VM<'a>, _| vm.op_mload(),
        82 => |vm: &mut VM<'a>, _| vm.op_mstore(),
        83 => |vm: &mut VM<'a>, _| vm.op_mstore8(),
        84 => |vm: &mut VM<'a>, _| vm.op_sload(),
        85 => |vm: &mut VM<'a>, _| vm.op_sstore(),
        86 => |vm: &mut VM<'a>, _| vm.op_jump(),
        87 => |vm: &mut VM<'a>, _| vm.op_jumpi(),
        88 => |vm: &mut VM<'a>, _| vm.op_pc(),
        89 => |vm: &mut VM<'a>, _| vm.op_msize(),
        90 => |vm: &mut VM<'a>, _| vm.op_gas(),
        91 => |vm: &mut VM<'a>, _| vm.op_jumpdest(),
        92 => |vm: &mut VM<'a>, _| vm.op_tload(),
        93 => |vm: &mut VM<'a>, _| vm.op_tstore(),
        94 => |vm: &mut VM<'a>, _| vm.op_mcopy(),
        95 => |vm: &mut VM<'a>, _| vm.op_push0(),
        240 => |vm: &mut VM<'a>, _| vm.op_create(),
        241 => |vm: &mut VM<'a>, _| vm.op_call(),
        242 => |vm: &mut VM<'a>, _| vm.op_callcode(),
        243 => |vm: &mut VM<'a>, _| vm.op_return(),
        244 => |vm: &mut VM<'a>, _| vm.op_delegatecall(),
        245 => |vm: &mut VM<'a>, _| vm.op_create2(),
        250 => |vm: &mut VM<'a>, _| vm.op_staticcall(),
        253 => |vm: &mut VM<'a>, _| vm.op_revert(),
        255 => |vm: &mut VM<'a>, _| vm.op_selfdestruct(),
        96..=127 => |vm: &mut VM<'a>, op: u8| vm.op_push(op as usize - 95),
        // DUPn
        128..=143 => |vm: &mut VM<'a>, op: u8| vm.op_dup(op as usize - 127),
        // SWAPn
        144..=159 => |vm: &mut VM<'a>, op: u8| vm.op_swap(op as usize - 143),
        160..=164 => |vm: &mut VM<'a>, op: u8| vm.op_log(op - 160),
        _ => |_, _| Err(VMError::InvalidOpcode),
    }
}

pub fn build_opcode_handler_map<'a>() -> [fn(&mut VM<'a>, u8) -> Result<OpcodeResult, VMError>; 256]
{
    let f: fn(&mut VM<'a>, u8) -> Result<OpcodeResult, VMError> =
        |_, _| Err(VMError::InvalidOpcode);
    let mut map = [f; 256];
    for i in 0..256 {
        map[i] = from_u8(i as u8);
    }
    map
}
